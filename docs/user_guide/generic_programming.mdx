---
id: generic_programming
title: Generic programming
sidebar_label: Generic programming
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

**nalgebra** allows several kind of generic programming, either through traits
of the **simba** crate, or by keeping the various type parameters of the
`Matrix<T, R, C, S>` structure and the likes. In the end, this allows for:
* **Genericity wrt. scalars**: the most common kind of abstraction.
  This allows you to write code that will work on any scalar group like `i32`
  and fields like `f32` or `f64`.
* **Dimensional genericity**: allows you to write code that will work
  generically for 2D, 3D, and higher dimensions.
* **Allocation type genericity**: you can write code that will work for
either static (`SVector`, `SMatrix`) or dynamic (`DVector`, `DMatrix`) types.


## Genericity wrt. scalars
This allows to write code that works with algebraic entities constructed on top
of a generic scalar type, e.g., floating-point numbers like `f32` or `f64` and
in some more restrictive cases integers like `i32` or `u64`.  This can be
achieved by keeping generic the first type parameter `T` of any structure of
**nalgebra** (including aliases). The mandatory trait bound of `T` is
`na::Scalar` which imposes some simple non-mathematical properties, i.e., `T`
must copyable, printable (using the `{:?}` [format
string](https://doc.rust-lang.org/std/fmt/index.html#formatting-traits)), and
comparable using the equality operator. Other commonly used trait bounds for
`T` are `na::RealField` or `na::ComplexField` from the
[simba](https://docs.rs/simba) crate. This
enables operator overloading and useful mathematical functions for signed
integers and floating point numbers respectively. Note that the `Scalar` trait
bound does not have to be specified if `Real` already is.

```rust
use na::{RealField, Scalar, Vector3};

fn print_vector<T: Scalar>(m: &Vector3<T>) {
  println!("{:?}", m)
}

fn print_norm<T: RealField>(v: &Vector3<T>) {
  // NOTE: alternatively, nalgebra already defines `v.norm()`.
  let norm = v.dot(v).sqrt();

  // The Real bound implies that T is Display so we can
  // use "{}" instead of "{:?}" for the format string.
  println!("{}", norm)
}

fn main() {
  let v1 = Vector3::new(1, 2, 3);
  let v2 = Vector3::new(1.0, 2.0, 3.0);

  print_vector(&v1);
  print_norm(&v2);
}
```

## Allocation type genericity

This allow you to write code that can operate on either the static or dynamic types
provided by nalgebra.

### Functions

```rust
fn add_vectors<D>(
    x: &nalgebra::OVector<f64, D>,
    y: &nalgebra::OVector<f64, D>,
) -> nalgebra::OVector<f64, D>
where
    D: nalgebra::Dim,
    nalgebra::DefaultAllocator: nalgebra::base::allocator::Allocator<f64, D>,
{
    x + y
}

fn main() {
    let static_vector1 = nalgebra::vector![1.0, 2.0];
    let static_vector2 = nalgebra::vector![2.0, 3.0];

    let dynamic_vector1 = nalgebra::dvector![1.0, 2.0];
    let dynamic_vector2 = nalgebra::dvector![2.0, 3.0];

    assert_eq!(add_vectors(&static_vector1, &static_vector2), nalgebra::vector![3.0, 5.0]);
    assert_eq!(add_vectors(&dynamic_vector1, &dynamic_vector2), nalgebra::dvector![3.0, 5.0]);
}
```

The following example won't compile, as the `OVector` type is a placeholder
for either static or dynamic type, but they must match:

```rust
      add_vectors(&dynamic_vector1, &static_vector1);
```

The error message is quite explicit:

```rust
error[E0308]: mismatched types
  --> src/bin/main.rs:22:35
   |
22 |     add_vectors(&dynamic_vector1, &static_vector1);
   |                                   ^^^^^^^^^^^^^^^ expected struct `Dynamic`, found struct `Const`
   |
   = note: expected reference `&Matrix<f64, Dynamic, Const<1_usize>, VecStorage<f64, Dynamic, Const<1_usize>>>`
              found reference `&Matrix<f64, Const<2_usize>, Const<1_usize>, ArrayStorage<f64, 2_usize, 1_usize>>`
```
For static vectors, you benefit from a compile-time dimensions check:

```rust
    let static_vector1 = nalgebra::vector![1.0, 2.0];
    let static_vector2 = nalgebra::vector![0.0, 1.0, 2.0];

    add_vectors(&static_vector1, &static_vector2);
```

This previous code will fail to compile, with the following error message:

```rust
error[E0308]: mismatched types
  --> src/bin/main.rs:25:34
   |
25 |     add_vectors(&static_vector1, &static_vector2);
   |                                  ^^^^^^^^^^^^^^^ expected `2_usize`, found `3_usize`
   |
   = note: expected reference `&Matrix<f64, Const<2_usize>, Const<1_usize>, ArrayStorage<f64, 2_usize, 1_usize>>`
              found reference `&Matrix<{float}, Const<3_usize>, Const<1_usize>, ArrayStorage<{float}, 3_usize, 1_usize>>`
```

However, if your are passing dynamic vectors, no check will be performed
and the code will panic at runtime as you are trying to add two vectors of different sizes:

```rust
    let dynamic_vector1 = nalgebra::dvector![1.0, 2.0];
    let dynamic_vector2 = nalgebra::dvector![0.0, 1.0, 2.0];

    add_vectors(&dynamic_vector1, &dynamic_vector2);
```

```rust
     Running `target/debug/main`
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `(2, 1)`,
 right: `(3, 1)`: Matrix addition/subtraction dimensions mismatch.
```

You can either implement a check within your code to avoid the panic and return an error,
or you leave it the the function caller responsability to pass the correct arguments.

### Struct

It is possible to use the same tricks in order to declare structs:

```rust
struct Equations<'a, D>
where
    D: nalgebra::Dim,
    nalgebra::DefaultAllocator: nalgebra::base::allocator::Allocator<f64, D>,
{
    pub equations_left_side: &'a nalgebra::OVector<f64, D>,
    pub equations_right_side: &'a nalgebra::OVector<f64, D>,
}

impl<'a, D> Equations<'a, D>
where
    D: nalgebra::Dim,
    nalgebra::DefaultAllocator: nalgebra::base::allocator::Allocator<f64, D>,
{
    fn difference(&self) -> nalgebra::OVector<f64, D> {
        self.equations_left_side - self.equations_right_side
    }
}
fn main() {
    let static_vector1 = nalgebra::vector![1.0, 2.0];
    let static_vector2 = nalgebra::vector![2.0, 3.0];

    let dynamic_vector1 = nalgebra::dvector![1.0, 2.0];
    let dynamic_vector2 = nalgebra::dvector![2.0, 3.0];

    let static_equations = Equations {
        equations_left_side: &static_vector1,
        equations_right_side: &static_vector2,
    };

    assert_eq!(static_equations.difference(), nalgebra::vector![-1.0, -1.0]);

    let dynamic_equations = Equations {
        equations_left_side: &dynamic_vector1,
        equations_right_side: &dynamic_vector2,
    };

    assert_eq!(dynamic_equations.difference(), nalgebra::dvector![-1.0, -1.0]);
}
```


### Trait

It is possible to use the same pattern for trait.

However, when implementing the given trait for specific cases,
one has to indicate the type for each it is implemented, either:
- `nalgebra::Dynamic`
- `nalgebra::Const`


```rust
pub trait Trait<D>
where
    D: nalgebra::Dim,
    nalgebra::DefaultAllocator: nalgebra::base::allocator::Allocator<f64, D>,
{
    fn copy_elements(&self) -> nalgebra::OVector<f64, D>;
}

pub struct DVectorWrapper<'a> {
    vector: &'a nalgebra::DVector<f64>,
}

impl<'a> DVectorWrapper<'a> {
    pub fn new(vector: &'a nalgebra::DVector<f64>) -> Self {
        DVectorWrapper { vector }
    }
}

impl<'a> Trait<nalgebra::Dynamic> for DVectorWrapper<'a> {
    fn copy_elements(&self) -> nalgebra::DVector<f64> {
        let output: nalgebra::DVector<f64> = self.vector.clone();
        output
    }
}

pub struct SVectorWrapper<'a> {
    vector: &'a nalgebra::SVector<f64, 2>,
}

impl<'a> SVectorWrapper<'a> {
    pub fn new(vector: &'a nalgebra::SVector<f64, 2>) -> Self {
        SVectorWrapper { vector }
    }
}

impl<'a> Trait<nalgebra::Const<2>> for SVectorWrapper<'a> {
    fn copy_elements(&self) -> nalgebra::SVector<f64, 2> {
        let output: nalgebra::SVector<f64, 2> = self.vector.clone();
        output
    }
}

fn main() {
    let static_vector = nalgebra::vector![1.0, 2.0];
    let dynamic_vector = nalgebra::dvector![1.0, 2.0];

    let dynamic_wrapper = DVectorWrapper::new(&dynamic_vector);
    let static_wrapper = SVectorWrapper::new(&static_vector);

    assert_eq!(dynamic_wrapper.copy_elements(), dynamic_vector);
    assert_eq!(static_wrapper.copy_elements(), static_vector);
}
```

In this previous example, you will get a compile-time error if you try to instanciate
a `DVectorWrapper` with a static vector or a `SVectorWrapper` with a dynamic vector


### Matrix

Matrices works the same as vector and you have `DMatrix`, `SMatrix` and `OMatrix`.

For square matrices, you will do the following:

```rust
fn print_matrix<D>(input: &nalgebra::OMatrix<f64, D, D>)
where
    D: nalgebra::Dim,
    nalgebra::DefaultAllocator: nalgebra::base::allocator::Allocator<f64, D, D>,
{
    for elt in input {
        println!("{}", elt);
    }
}

fn main() {
    let static_matrix = nalgebra::matrix![1.0, 2.0; 3.0, 4.0];
    let dynamic_matrix = nalgebra::dmatrix![5.0, 6.0; 7.0, 8.0];

    print_matrix(&static_matrix);
    print_matrix(&dynamic_matrix);
}
```

For non-square matrices, you will do:

```rust
fn print_matrix<D, E>(input: &nalgebra::OMatrix<f64, D, E>)
where
    D: nalgebra::Dim,
    E: nalgebra::Dim,
    nalgebra::DefaultAllocator: nalgebra::base::allocator::Allocator<f64, D, E>,
{
    for elt in input {
        println!("{}", elt);
    }
}

fn main() {
    let static_matrix = nalgebra::matrix![1.0, 2.0, 3.0; 4.0, 5.0, 6.0];
    let dynamic_matrix = nalgebra::dmatrix![5.0, 6.0, 7.0; 8.0, 9.0, 10.0];

    print_matrix(&static_matrix);
    print_matrix(&dynamic_matrix);
}

```

### Vectors and Matrices

You can also mix vectors and matrix and constraint dimensions

The following example show a vector and a square matrix with the same dimensions:

```rust
fn print_elements<D>(vector: &nalgebra::OVector<f64, D>, matrix: &nalgebra::OMatrix<f64, D, D>)
where
    D: nalgebra::Dim,
    nalgebra::DefaultAllocator: nalgebra::base::allocator::Allocator<f64, D>,
    nalgebra::DefaultAllocator: nalgebra::base::allocator::Allocator<f64, D, D>,
{
    for elt in vector {
        println!("{}", elt);
    }

    for elt in matrix {
        println!("{}", elt);
    }
}

fn main() {
    let static_matrix = nalgebra::matrix![1.0, 2.0; 4.0, 5.0];
    let static_vector = nalgebra::vector![1.0, 2.0];

    print_elements(&static_vector, &static_matrix);
}
```