---
id: generic_programming
title: Generic programming
sidebar_label: Generic programming
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

**nalgebra** allows several kind of generic programming, either through traits
of the **simba** crate, or by keeping the various type parameters of the
`Matrix<T, R, C, S>` structure and the likes. In the end, this allows for:
* **Genericity wrt. scalars**: the most common kind of abstraction.
  This allows you to write code that will work on any scalar group like `i32`
  and fields like `f32` or `f64`.
* **Dimensional genericity**: allows you to write code that will work
  generically for 2D, 3D, and higher dimensions.
* **Allocation type genericity**: you can write code that will work for
either static (`SVector`, `SMatrix`) or dynamic (`DVector`, `DMatrix`) types.


## Genericity wrt. scalars
This allows to write code that works with algebraic entities constructed on top
of a generic scalar type, e.g., floating-point numbers like `f32` or `f64` and
in some more restrictive cases integers like `i32` or `u64`.  This can be
achieved by keeping generic the first type parameter `T` of any structure of
**nalgebra** (including aliases). The mandatory trait bound of `T` is
`na::Scalar` which imposes some simple non-mathematical properties, i.e., `T`
must copyable, printable (using the `{:?}` [format
string](https://doc.rust-lang.org/std/fmt/index.html#formatting-traits)), and
comparable using the equality operator. Other commonly used trait bounds for
`T` are `na::RealField` or `na::ComplexField` from the
[simba](https://docs.rs/simba) crate. This
enables operator overloading and useful mathematical functions for signed
integers and floating point numbers respectively. Note that the `Scalar` trait
bound does not have to be specified if `Real` already is.

```rust
use na::{RealField, Scalar, Vector3};

fn print_vector<T: Scalar>(m: &Vector3<T>) {
  println!("{:?}", m)
}

fn print_norm<T: RealField>(v: &Vector3<T>) {
  // NOTE: alternatively, nalgebra already defines `v.norm()`.
  let norm = v.dot(v).sqrt();

  // The Real bound implies that T is Display so we can
  // use "{}" instead of "{:?}" for the format string.
  println!("{}", norm)
}

fn main() {
  let v1 = Vector3::new(1, 2, 3);
  let v2 = Vector3::new(1.0, 2.0, 3.0);

  print_vector(&v1);
  print_norm(&v2);
}
```

## Allocation type genericity
This allow you to write code that can operate on either the static or dynamic types
provided by nalgebra.

### Functions

```rust
fn add_vectors<D>(
    x: &nalgebra::OVector<f64, D>,
    y: &nalgebra::OVector<f64, D>,
) -> nalgebra::OVector<f64, D>
where
    D: nalgebra::Dim,
    nalgebra::DefaultAllocator: nalgebra::base::allocator::Allocator<f64, D>,
{
    x + y
}

fn main() {
    let static_vector1 = nalgebra::vector![1.0, 2.0];
    let static_vector2 = nalgebra::vector![2.0, 3.0];

    let dynamic_vector1 = nalgebra::dvector![1.0, 2.0];
    let dynamic_vector2 = nalgebra::dvector![2.0, 3.0];

    assert_eq!(add_vectors(&static_vector1, &static_vector2), nalgebra::vector![3.0, 5.0]);
    assert_eq!(add_vectors(&dynamic_vector1, &dynamic_vector2), nalgebra::dvector![3.0, 5.0]);
}
```

The following example won't compile, as the `OVector` type is a placeholder
for either static or dynamic type, but they must match:

```rust
      add_vectors(&dynamic_vector1, &static_vector1);
```

The error message is quite explicit:

```rust
error[E0308]: mismatched types
  --> src/bin/main.rs:22:35
   |
22 |     add_vectors(&dynamic_vector1, &static_vector1);
   |                                   ^^^^^^^^^^^^^^^ expected struct `Dynamic`, found struct `Const`
   |
   = note: expected reference `&Matrix<f64, Dynamic, Const<1_usize>, VecStorage<f64, Dynamic, Const<1_usize>>>`
              found reference `&Matrix<f64, Const<2_usize>, Const<1_usize>, ArrayStorage<f64, 2_usize, 1_usize>>`
```
For static vectors, you benefit from a compile-time dimensions check:

```rust
    let static_vector1 = nalgebra::vector![1.0, 2.0];
    let static_vector2 = nalgebra::vector![0.0, 1.0, 2.0];

    add_vectors(&static_vector1, &static_vector2);
```

This previous code will fail to compile, with the following error message:

```rust
error[E0308]: mismatched types
  --> src/bin/main.rs:25:34
   |
25 |     add_vectors(&static_vector1, &static_vector2);
   |                                  ^^^^^^^^^^^^^^^ expected `2_usize`, found `3_usize`
   |
   = note: expected reference `&Matrix<f64, Const<2_usize>, Const<1_usize>, ArrayStorage<f64, 2_usize, 1_usize>>`
              found reference `&Matrix<{float}, Const<3_usize>, Const<1_usize>, ArrayStorage<{float}, 3_usize, 1_usize>>`
```

However, if your are passing dynamic vectors, no check will be performed
and the code will panic at runtime as you are trying to add two vectors of different sizes:

```rust
    let dynamic_vector1 = nalgebra::dvector![1.0, 2.0];
    let dynamic_vector2 = nalgebra::dvector![0.0, 1.0, 2.0];

    add_vectors(&dynamic_vector1, &dynamic_vector2);
```

```rust
     Running `target/debug/main`
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `(2, 1)`,
 right: `(3, 1)`: Matrix addition/subtraction dimensions mismatch.
```

You can either implement a check within your code to avoid the panic and return an error,
or you leave it the the function caller responsability to pass the correct arguments.

### Struct

It is possible to use the same tricks in order to declare structs:

```rust
struct Equations<'a, D>
where
    D: nalgebra::Dim,
    nalgebra::DefaultAllocator: nalgebra::base::allocator::Allocator<f64, D>,
{
    pub equations_left_side: &'a nalgebra::OVector<f64, D>,
    pub equations_right_side: &'a nalgebra::OVector<f64, D>,
}

impl<'a, D> Equations<'a, D>
where
    D: nalgebra::Dim,
    nalgebra::DefaultAllocator: nalgebra::base::allocator::Allocator<f64, D>,
{
    fn difference(&self) -> nalgebra::OVector<f64, D> {
        self.equations_left_side - self.equations_right_side
    }
}
fn main() {
    let static_vector1 = nalgebra::vector![1.0, 2.0];
    let static_vector2 = nalgebra::vector![2.0, 3.0];

    let dynamic_vector1 = nalgebra::dvector![1.0, 2.0];
    let dynamic_vector2 = nalgebra::dvector![2.0, 3.0];

    let static_equations = Equations {
        equations_left_side: &static_vector1,
        equations_right_side: &static_vector2,
    };

    assert_eq!(static_equations.difference(), nalgebra::vector![-1.0, -1.0]);

    let dynamic_equations = Equations {
        equations_left_side: &dynamic_vector1,
        equations_right_side: &dynamic_vector2,
    };

    assert_eq!(dynamic_equations.difference(), nalgebra::dvector![-1.0, -1.0]);
}
```


### Trait

### Matrix